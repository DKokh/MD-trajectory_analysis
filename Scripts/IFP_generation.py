#!/usr/bin/env python
# coding: utf-8

# # Package for generation of Ligand-Protein Interaction Fingerprints from MD trajectories (dcd format):
#     IFP include : 
#         PL H-bonds
#         PL salt bridges
#         PL hydrophobic contacs
#         PL bonds that involve aromatic rings
#         PL bonds that involve hylogen atom
#         P-water-L bonds
# 
# ### Author: Daria Kokh
#     v.1.0
#     Copyright (c) 2019
#     Released under the GNU Public Licence, v2 or any higher version
#     
# 
# 
# ### Input data required:
#     - trajectory file 
#     - pdb file (for example, generated from the first frame)
#     - ligand mole2 and pdb files
#     
#     
# ### Packages required:
#     numpy
#     pandas
#     matplotlib
#     MDAnalysis
#         Important!   MDAnalysis must be uploaded from developer version see
#     RDkit
#     scipy
#     code is written on Python 3.x
#
# ### Package Overview:
# 
#     IFP_list(property_list, sel_ligands) - generation a list of IFP types based on the ligand atom type
#     make_IFT_table(IFP_prop_list,snaps)  - generation of IFP data table 
#     IFP(u_mem,sel_ligands,property_list,WB_analysis = True,ligand_radius =0) - generation of an IFP lists
#     table_combine (df_HB,df_WB,df_prop,ligand_name,residues_name = [],start=0,stop=None,step=1)
#     read_IFP(list_IFP)
#     Plot_IFP(df,contact_collection=None
# 
# 



import glob, os
import sys
import subprocess
import numpy as np

import pandas as pd
from pandas import ExcelFile 

from matplotlib import *
from matplotlib import cm
import matplotlib.ticker
from matplotlib import gridspec
from matplotlib import gridspec
import  pylab as plt
import seaborn
import seaborn as sns

from scipy import stats

from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import EState
from rdkit.Chem import MolDb
from rdkit.Chem import QED
from rdkit.Chem import rdchem
from rdkit.Chem import ChemicalFeatures
from rdkit import RDConfig
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw

import MDAnalysis as mda
from MDAnalysis.lib.formats.libdcd import DCDFile
from MDAnalysis.analysis import contacts,align,rms
from MDAnalysis.analysis.base import AnalysisFromFunction
from MDAnalysis.coordinates.memory import MemoryReader
import MDAnalysis.analysis.hbonds as hb


import warnings
warnings.filterwarnings("ignore")




#######################################################################
#
#      FUNCTION FOR computing of contact properties for a particular compound and interaction type
#
#######################################################################

class  IFP_prop:
    """
    CLASS of the Interaction Fingerprint properties for particular type of the protein-ligand interection
    
    name - type of interaction
    atoms -ligand atom of that belong to this type
    sel_a - string describing a selection of protein residues/atoms 
    sel_b - string describing a selection of ligand atoms 
    dist - distance to be used for analysis
    contacts - list of contact 
    """
    def __init__(self,name,atoms,sel_a,sel_b,dist):
        self.name = name   
        self.atoms = atoms   
        self.sel_a = sel_a   
        self.sel_b = sel_b    
        self.dist = dist     
        self.contacts = []  


#------------------------

#######################################################################
#
#      FUNCTION taht makes a list for computing specific contacts using MDAnalysis
#
#######################################################################
    
def IFP_list(property_list, sel_ligands):
    """
    Parameters:
    property_list - ligand atom properties as generated by Rdkit
    sel_ligands - ligand residue name
    Returns:
    a list of properties that can be then used to extract IFP from a snapshot
    """
    
    IFP_prop_list = []
    try:  # hydrophobic
        line = ""
        for l in tuple(set(property_list["Hydrophobe"])): line = line + l + " "
        sel_a = "(type C and (not  (name CG andresname ASN ASP))                    and (not  (name CG and resname GLU GLN ARG))                   and (not  (name CZ and resname TYR ARG))                   and (not  (name CE and resname LYS))                   and (not  (name C and backbone)))"                 
        sel_b = '((resname '+sel_ligands+") and (name "+line+") )"
        IFP_prop_list.append(IFP_prop("HY",line,sel_a,sel_b,4.5))
    except:
        pass
    """    
    try:
        line = ""
        for l in tuple(set(property_list["LumpedHydrophobe"])): line = line + l + " "
        sel_a = "((resname PHE TRP HIS TYR ) and (name CD* CG* CB* CE* ))"
        sel_b = '((resname '+sel_ligands+") and (name "+line+"))"
        IFP_prop_list.append(IFP_prop("LU",line,sel_a,sel_b,3.5))
    except:
        pass
    """    
    try:  #--- salt bridge with posetively-charged residues 
        line = ""
        for l in tuple(set(property_list["PosIonizable"])): line = line + l +" "
        sel_a = "((resname ASP GLU) and (name OE* OD*)) "
        sel_b = '((resname '+sel_ligands+") and (name "+line+") )"
        IFP_prop_list.append(IFP_prop("IP",line,sel_a,sel_b,4))
    except:
        pass
    
    try: #--- salt bridges with negatively charged residues  
        line = ""
        for l in tuple(set(property_list["NegIonizable"])): line = line + l +" "
        sel_a = "((resname ARG LYS ) and (name NH* NZ)) or ((resname HI2 ) and (name HD HE))"
        sel_b = '((resname '+sel_ligands+") and (name "+line+") )"
        IFP_prop_list.append(IFP_prop("IN",line,sel_a,sel_b,4))
    except:
        pass
    
    try:  #--- cation-aril interactions  
        line = ""
        for l in tuple(set(property_list["PosIonizable"])): line = line + l +" "
        sel_a = "((resname PHE TRP TYR HIS HIE HID) and (name CZ* CD* CE* CG* CH* NE* ND*))"
        sel_b = '((resname '+sel_ligands+") and (name "+line+") )"
        IFP_prop_list.append(IFP_prop("AR",line,sel_a,sel_b,5))
    except:
        pass

    try: #--- aromatic stacking 
        line = ""
        for l in tuple(set(property_list["Aromatic"])): line = line + l +" "
        sel_a = "((resname PHE TRP TYR HI2 HIS HIE HID) and (name CZ* CD* CE* CG* CH* NE* ND*)) "
        IFP_prop_list.append(IFP_prop("AR",line,sel_a,sel_b,5))
    except:
        pass

    try: #--- S -aromatic 
        sel_b = '((resname '+sel_ligands+") and (type S ))"
        sel_a = "((resname PHE TRP TYR HI2 HIS HIE HID) and (name CZ* CD* CE* CG* CH* NE* ND*)) "
        IFP_prop_list.append(IFP_prop("AR",line,sel_a,sel_b,4.5))
    except:
        pass
    
    try: #--- aromatic - cation interactions
        line = ""
        for l in tuple(set(property_list["Aromatic"])): line = line + l +" "
        sel_a = " ((resname ARG LYZ ) and (name NH* NZ* )) or (backbone and type N)"
        IFP_prop_list.append(IFP_prop("AR",line,sel_a,sel_b,5))
    except:
        pass

    try: #--- aromatic - S/amide interactions
        line = ""
        for l in tuple(set(property_list["Aromatic"])): line = line + l +" "
        sel_a = " ((type S) and (resname MET CYS)) or (backbone and type N)"
        IFP_prop_list.append(IFP_prop("AR",line,sel_a,sel_b,4.5))
    except:
        pass
    
    try: #--- hylogen bonds with atromatic or backbone carbonyl oxygen
        sel_a = "((resname PHE TRP TYR HIS HIE HID) and (name CZ* CD* CE* CG* CH* NE* ND*))             or (backbone and name O) or ((resname ASP GLU) and (name OE* OD*))             or ((resname CYS MET) and (type S))"
        sel_b = '((resname '+sel_ligands+") and (name I Cl Br) )"
        IFP_prop_list.append(IFP_prop("AR","HL",sel_a,sel_b,3.5))
    except:
        pass
    try: # water shell  
#        sel_a = "((sphzone 12.0 resname "+sel_ligands+") and (resname WAT and type O))"
        sel_a = " (resname WAT and type O)"
        sel_b = '(resname '+sel_ligands+") and (not type H)"
        IFP_prop_list.append(IFP_prop("WA","HE",sel_a,sel_b,3.5))
    except:
        pass
    try: # any protein-ligand contacts 
        sel_a = "(protein) and (not type H)"
        sel_b = '(resname '+sel_ligands+") and (not type H)"
        IFP_prop_list.append(IFP_prop("RE","HE",sel_a,sel_b,4))
    except:
        pass
    return (IFP_prop_list)


#######################################################################
#
#      FUNCTION to combine a list of IFP of a particular trajectory in one matrix
#
#######################################################################
def make_IFT_table(IFP_prop_list,snaps):
    """
    Most of interections are taken from the list given in 
    https://www.cambridgemedchemconsulting.com/resources/molecular_interactions.html
    Parameters:
    IFP_prop_list list of IFP objects 
    Returns:
    column names and matrix with IFP values
    """
    
    # first make a list of all types of contacts observed (columns)
    columns = []
    for IFP_type  in IFP_prop_list:  # loop over frames
        for s in IFP_type.contacts:  # loop over different contacts
            for c in s[1]:           # loop over  particular contacts in a particular frame
                if(IFP_type.name == "WA"):
                    IFP_element = "WAT"
                else:# combine contact type with residues type and name
                    IFP_element = IFP_type.name+"_"+c[0]+str(c[1])  
                if IFP_element not in columns: columns.append(IFP_element)

    times = np.linspace(0,snaps,snaps)
        
    columns = np.asarray(columns).flatten()
    IFP_matrix=np.zeros((len(times),len(columns)),dtype = np.int8)
    
    for IFP_type  in IFP_prop_list: # loop over different contacts
        for s in IFP_type.contacts: # loop over frames
            for c in s[1]:          # loop over  particular contacts in a particular frame
                if(IFP_type.name == "WA"):
                    IFP_element = "WAT"
                else:# combine contact type with residues type and name
                    IFP_element = IFP_type.name+"_"+c[0]+str(c[1]) 
                col = np.argwhere(columns == IFP_element).flatten()[0]
                try:
                    if((IFP_type.name == "WA") ): IFP_matrix[s[0],col] += 1
                    else: IFP_matrix[s[0],col] = 1
                except:
                    print("IFP was not found: ",IFP_element,col,s[0])
    return(columns,IFP_matrix)

#######################################################################
#
#     FUNCTION FOR generation of interaction fingerprints (IFP) in a trajectory
#
#######################################################################
def IFP(u_mem,sel_ligands,property_list,WB_analysis = True,):
    """
    Parameters:
    u - trajectory - universe object
    ligand name -  ligand residue name
    property_list - python dictionary of ligand atom properties (created by ligand_analysis)
    Reterns:
    """

    #---------------------------------------------------------------
    #- find hydrogen bonds between ptotein and ligand  
    donor_list = []
    hb.HydrogenBondAnalysis.DEFAULT_DONORS['OtherFF'] = hb.HydrogenBondAnalysis.DEFAULT_DONORS['CHARMM27']
    hb.HydrogenBondAnalysis.DEFAULT_ACCEPTORS['OtherFF'] = hb.HydrogenBondAnalysis.DEFAULT_ACCEPTORS['CHARMM27']
    if "Donor" in set(property_list):
        donor_line = tuple(set(property_list["Donor"]))
        hb.HydrogenBondAnalysis.DEFAULT_DONORS['OtherFF'] = hb.HydrogenBondAnalysis.DEFAULT_DONORS['OtherFF']+donor_line
    if "Acceptor" in set(property_list):      
        acceptor_line = tuple(set(property_list["Acceptor"]))
        hb.HydrogenBondAnalysis.DEFAULT_ACCEPTORS['OtherFF'] = hb.HydrogenBondAnalysis.DEFAULT_ACCEPTORS['OtherFF']+acceptor_line
    
    h = hb.HydrogenBondAnalysis(u_mem, selection1 ='resname '+sel_ligands,selection2='all', distance=3.5, angle=120,                                  forcefield='OtherFF')
    print("Start HB analysis")
    h.run()
    h.generate_table()
    df_HB = pd.DataFrame.from_records(h.table)
    print("End HB analysis")
    
    #---------------------------------------------------------------
    #------ find water bridges between ligand and protein--------
    df_WB = pd.DataFrame()
    if WB_analysis :
        print("Start WB analysis")
        # will add O atom of water as an HB donor (it is concidered as acceptor by default assuming as a protein backbone atom)
        hb.HydrogenBondAnalysis.DEFAULT_DONORS['OtherFF'] = hb.HydrogenBondAnalysis.DEFAULT_DONORS['OtherFF']+tuple(set("O"))
        w = hb.WaterBridgeAnalysis(u_mem, 'resname '+sel_ligands, 'not resname WAT',water_selection=" resname WAT ",                                    distance=3.5, angle=110, forcefield='OtherFF')
        w.run()
        w.generate_table()
        df_WB = pd.DataFrame.from_records(w.table)
        print("End WB analysis")
        
    #---------------------------------------------------------------
    #------ find all other contacts--------   
    print("Start collecting protein-ligand IFPs")
    IFP_prop_list = IFP_list(property_list, sel_ligands)
    u_list_all = []
    for IFP_type  in IFP_prop_list:
        line = IFP_type.sel_a +" and around "+str(IFP_type.dist)+" "+ IFP_type.sel_b
        u_list_all.append(u_mem.select_atoms(line, updating=True))
    #--------------------------------------------------
  
    for i in range(len(u_mem.trajectory)):
        u_mem.trajectory[i] 
        for u_list,IFP_type  in zip(u_list_all,IFP_prop_list):
            found = []
            for u in u_list: found.append((u.resname,u.resid, u.name)) 
            if(found):  IFP_type.contacts.append((i,found))

    if(len(IFP_prop_list) > 0):
        columns,IFP_matrix = make_IFT_table(IFP_prop_list,len(u_mem.trajectory))
        df_prop = pd.DataFrame( data = IFP_matrix,index=None, columns=columns) 

    return(df_prop,df_HB,df_WB) 

####################################################################################################
#
# combine three tables 
#    with protein-ligand hydrogen bonds
#    with protein-ligand water bridges
#    with other protein-ligand interaction properties(IFP)
# in one table
#
####################################################################################################
def table_combine (df_HB,df_WB,df_prop,ligand_name,residues_name = [],start=0,stop=None,step=1):
    """
    Patameters:
    df_HB - H-bond table
    df_prop - IFP table 
    ligand_name - ligand nale
    residues_name a list of properties that (column names) that can be used to generate tables with the same column list
    Return:
    updated table
    """
    if stop :
        if len(range(start,stop,step)) != np.asarray(df_prop.shape[0]):
            stop = (df_prop.shape[0] -start)*step
    else:
        stop = df_prop.shape[0]
        
#---------------- extract hydrogen bonds between ligand and protein and add to IFP table----------        
    columns_resname = []
    df_prop["time"] =range(start,stop,step)
    #------- list of the residues making donor-HB  with the  ligand, but not water
    df_noWatD = df_HB[~df_HB.donor_resnm.isin([ligand_name,"WAT"])]  # protein donor
    df_noWatD = df_noWatD[df_noWatD.acceptor_resnm == ligand_name]   # protein donor and ligand acceprot
    
    #------- list of the residues making acceptor-HB  with the  ligand , but not water
    df_noWatA = df_HB[~df_HB.acceptor_resnm.isin([ligand_name,"WAT"])]  # protein acceptor
    df_noWatA = df_noWatA[df_noWatA.donor_resnm == ligand_name]  # protein acceptor and ligand donor

    t_list = []    
    for t in df_HB.time.unique().tolist():
        raw = int(t)
        if not df_noWatD.empty:
            df_noWatD_t = df_noWatD[(df_noWatD.time == t)]
            if not df_noWatD_t.empty:
                for d in df_noWatD_t.donor_resid.tolist():
                    r = "HD_"+df_noWatD_t[df_noWatD_t.donor_resid == d].donor_resnm.tolist()[0]+str(d)
                    if r not in columns_resname:  columns_resname.append(r)
                    t_list.append((raw,r))
        if not df_noWatA.empty:
            df_noWatA_t = df_noWatA[(df_noWatA.time == t)]
            if not df_noWatA_t.empty:
                for d in df_noWatA_t.acceptor_resid.tolist():
                    r = "HA_"+df_noWatA_t[df_noWatA_t.acceptor_resid == d].acceptor_resnm.tolist()[0]+str(d)
                    if r not in columns_resname:  columns_resname.append(r)
                    t_list.append((raw,r))
    properties =  np.zeros((len(df_prop.index.values.tolist()),len(columns_resname)),dtype=np.int8)
    for j,c in enumerate(np.sort(np.asarray(columns_resname))):
        for i,cc in enumerate(t_list):
            if(c == cc[1]):   
                properties[cc[0],j] = 1
        df_prop[c] =   properties[:,j]    
#    print("--------------HB found------\n")
    
            
#---------------- extract water bridges between ligand and protein and add to IFP table----------
    if not df_WB.empty:
        df_WB_IA = df_WB[df_WB["acceptor_resnm"] == ligand_name]  # all lines with ligand acceptor
        df_WB_ID = df_WB[df_WB["donor_resnm"] == ligand_name]  # all lines with ligand donor
    
        df_WB_WA = df_WB_ID[df_WB_ID["acceptor_resnm"] == "WAT"] # all lines with ligand donor and water acceptor 
        df_WB_WD = df_WB_IA[df_WB_IA["donor_resnm"] == "WAT"] # all lines with ligand acceptor and water donor
        t_list = []
        #--- loop over time-frames -------------------------
        column_resi = []
        for t in df_HB.time.unique().tolist():
            raw = int(t)
            # now select part of the table for a particular time-frame
            df_WB_t = df_WB[(df_WB.time == t)]
            df_WB_WA_t = df_WB_WA[(df_WB_WA.time == t)]
            df_WB_WD_t = df_WB_WD[(df_WB_WD.time == t)]
            #------ lists of  water donors  and water acceptors
            water_list_A = np.unique(np.asarray(df_WB_WA_t.acceptor_resid.tolist()))
            water_list_D =  np.unique(np.asarray(df_WB_WD_t.donor_resid.tolist()))
            water_list = np.concatenate((water_list_A,water_list_D))
            # print(raw,"+Wat  ",water_list)
        
            # select lines without ligand atoms and with just one water (either donor or acceptor)  
            if not df_WB_t.empty:
                df_t = df_WB_t[(df_WB_t.acceptor_resnm != ligand_name) & (df_WB_t.donor_resnm != ligand_name) &                   ((df_WB_t.acceptor_resnm != "WAT") | (df_WB_t.donor_resnm != "WAT"))] # 
                if not df_t.empty:
                # select lines with water from the list of waters interacting with the ligand
                    df_P1 = df_t[(df_t.acceptor_resid.isin(water_list) | (df_t.donor_resid.isin(water_list) ))]
                    df_P1_a = df_P1[df_P1.donor_resnm == "WAT"]
                    df_P1_d = df_P1[df_P1.acceptor_resnm == "WAT"]
                    for r in df_P1_a.acceptor_resid.tolist():
                        r1 = "WB_"+df_P1_a[df_P1_a.acceptor_resid == r].acceptor_resnm.tolist()[0]+str(r)
                        if r1 not in column_resi: 
                            column_resi.append(r1)
                        t_list.append((raw,r1))
                    for r in df_P1_d.donor_resid.tolist():
                        r1 = "WB_"+df_P1_d[df_P1_d.donor_resid == r].donor_resnm.tolist()[0]+str(r)
                        if r1 not in column_resi: 
                            column_resi.append(r1)
                        t_list.append((raw,r1))

        properties =  np.zeros((len(df_prop.index.values.tolist()),len(column_resi)),dtype=np.int8)
        for j,c in enumerate(column_resi):
            for i,cc in enumerate(t_list):
                if(c == cc[1]):   
                    properties[cc[0],j] = 1
            df_prop[c] =   properties[:,j]    
    
#-----------------------------------------------------------------    
    # add more columns for IFP provided as input but not found in the current--
    for rr in residues_name:
        if (rr in df_prop.columns.tolist()):   pass
        else:  df_prop[rr] = 0
            

#----------------------------------------------------------------        
    # cleaning the table 
    # fist order residues by number
    df_prop_order_new = []
    for df_prop_order in df_prop.columns.tolist():
        if df_prop_order.find("_") > 0:
            df_prop_order_new.append(int(df_prop_order[df_prop_order.find("_")+4:]))
        else: df_prop_order_new.append(0)            
    properties = np.asarray(df_prop.columns.tolist())[np.argsort(df_prop_order_new)]
    # then use order of the properties HY - HD - HA - IP - IN  
    for i_df in range(1,len(properties)):
        if (properties[i_df].find("_")> 0) and (properties[i_df-1].find("_")> 0):
            if(properties[i_df][properties[i_df].find("_"):] == properties[i_df-1][properties[i_df-1].find("_"):]):
                properties[i_df-1:i_df+1] = np.sort(properties[i_df-1:i_df+1])
#        print("---",properties)
    df_prop = df_prop[properties]
    #--- change column position puttinhg time at the beginning and Water at the end---
    df_prop = df_prop[np.concatenate((["time"],df_prop.columns[df_prop.columns != "time"].tolist()))]
    if "WAT" in df_prop.columns.tolist():
        df_prop = df_prop[np.concatenate((df_prop.columns[df_prop.columns != "WAT"].tolist(),["WAT"]))]
    
    return (df_prop)

#########################################################################
# Program for reading IFP databases
# Additionally column with ligand name is added
# and COM column is splitted to COM_x, COM_y, COM_z
########################################################################
def read_IFP(list_IFP):
    """
    Parameters:
    dictionary of files with ITP databases {name1:file_path1[,name2:filepath2],...}
    Returns:
    combined IFP database
    """
    unpickled_dfi = []
    ligandsi = []
    for lig in list_IFP:
        unpickled_dfi.append(pd.read_pickle(list_IFP[lig]))
        ligandsi.append(lig)

    # add ligand names and make a joint list of columns
    intersect = []
    for (df,lig) in zip(unpickled_dfi,ligandsi):
        df["ligand"] = np.repeat(lig,df.shape[0]) 
        diff = np.setdiff1d(np.asarray(df.columns.tolist()),intersect)
        if(len(intersect) == 0):  intersect = diff
        else: intersect = np.append(intersect,diff)
    
    # add empty columns for those that are present in the joint list but absent in the database
    unpickled_df = pd.DataFrame(columns=intersect) 
    for (df,lig) in zip(unpickled_dfi,ligandsi):
        for ifp in intersect:
            if ifp not in df.columns.tolist():
                df[ifp] = np.repeat(np.int8(0),df.shape[0])    
        unpickled_df = pd.concat([unpickled_df, df], axis=0, sort=False)

    # converge COM string to  x y z components
    if "COM"  in unpickled_df.columns.tolist():
        COM_x = []
        COM_y = []
        COM_z = []
        for l in unpickled_df.COM:
            COM_x.append(l[0])
            COM_y.append(l[1])
            COM_z.append(l[2])
        unpickled_df["COM_x"] = COM_x
        unpickled_df["COM_y"] = COM_y
        unpickled_df["COM_z"] = COM_z
    
    return(unpickled_df)


########################################
#
#     PLOT IFP  and ligand water shell for a trajectory
#
########################################
def Plot_IFP(df,contact_collection=None):
    """
    Parameters:
    df- IFP database
    contact_collection - set of IFP to be shown
    Returns:
    """
    color = ['r','b','forestgreen','lime','m','c','teal','orange','yellow','goldenrod','olive','tomato','salmon','seagreen']
    ifp_list = ["HY","AR","LU","HD","HA","IP","IN","WB"]
    columns_IFP = []  # standard IFP
    columns_CONT = []  # just contacts
    for c in df.columns.tolist():
        if c[0:2] in ifp_list:
            columns_IFP.append(c)
        elif c[0:2]  == "RE":
            columns_CONT.append(c)
                
    fig = plt.figure(figsize=(18, 6))
    
    ax = fig.add_subplot(131)
    ax.set_title('IFP')
    df1 = df[columns_IFP]
#    df1.loc['mean'] = df1.mean()
    sns.heatmap(df1)
    ax.set_title('IFP')
    
    ax = fig.add_subplot(132)
    ax.set_title('RE')
    df1 = df[columns_CONT]
    sns.heatmap(df1)
    ax.set_title('Contacts')
    
    if("WAT"  in df.columns.tolist()):
        ax = fig.add_subplot(133)
        ax.set_ylim(0,max(df["WAT"].tolist()))
        if ("Repl"  in df.columns.tolist()):
            for i,r in  enumerate(np.unique(df.Repl.tolist())):
                plt.plot(df[df.Repl == r]["WAT"], marker='o', linewidth = 0,color = color[i],label=r)
            plt.legend()
        else:
            plt.plot(df["WAT"],'go')
        ax.set_title('Water shell')
        ax.set_xlabel('frame')
        ax.set_ylabel('# of water molecules')
    plt.show()
    return

########################################
#
#     get ligand chemical properties
#
########################################
def  ligand_properties(ligand_pdb,ligand_mol2):
    """
    ligand_pdb - ligand structure file  in the PDB format
    ligand_mol2 - ligand structure file  in the Mol2 format (not all mol2 format work, but generated by MOE does)
    """
    ff=open(ligand_pdb,"r")
    lines = ff.readlines()
    ff.close()
    list_labels = []
    for line in lines:
        if line.split()[0] == 'ATOM': list_labels.append(line.split()[2]) 

    mol = Chem.rdmolfiles.MolFromMol2File(ligand_mol2,removeHs=False)   
    fdefName = os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef')
    factory = ChemicalFeatures.BuildFeatureFactory(fdefName)
    feats = factory.GetFeaturesForMol(mol)

    properties_list = {}
    for f in feats:
        prop = f.GetFamily()  #  get property name
        at_indx  = list(f.GetAtomIds())  # get atom index
        if prop not in properties_list.keys():
            properties_list[prop]=[]
        if(len(at_indx) > 0):
            for l in at_indx: properties_list[prop].append(list_labels[l])
        else: properties_list[prop].append(list_labels[at_indx[0]])
    return(properties_list)





