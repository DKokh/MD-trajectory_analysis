#!/usr/bin/env python
# coding: utf-8

# # Package for analysis of MD trajectories of a protein-ligand complex
# # in particular, those generated by tauRAMD protocol
# 
# 
# ### Author: Daria Kokh
#     v.1.0
#     Copyright (c) 2019
#     Released under the GNU Public Licence, v2 or any higher version
#     
# 
# 
# ### Input data required:
#     - a reference pdb file of the system (for example, generated from the first frame)
#     - ligand mol2 and pdb files
#     
#     
# ### Packages required:
#     numpy
#     pandas
#     matplotlib
#     MDAnalysis
#         Important!   MDAnalysis must be uploaded from developer version see
#     RDkit
#     scipy
#     code is written on Python 3.x
# 
# 

# ## Summary
# 
# #########################################################################
# 
# ### 1. class Traj_Properties:
# 
#     _init__(self):
# 
# #### Variables:
#         start = 0
#         stop = 0
#         step = 1
#         length = 0
#         df_properties = []  # Interaction fingerprients
#         rmsd_prot = []      # RMSD of the protein
#         rmsd_lig = []       # RMSD of the ligand
#         Rgr_prot = []       # radius of gyration for protein
#         Rgr_lig = []        # radius of gyration for ligand
# 
# 
# 
# ### 2. class trajectories:
# 
#     _init__(self,PRJ_DIR="./",namd_tmpl= "NAMD*",ramd_tmpl= "RAMD*",pdb ="ref.pdb",top ="ref.prmtop",ligand_names=[],Force=14)
#     
# #### Variables:
#         tau:
#             tau = None   [s]
#             tau_SD = None  [s]
#         namd:  
#             repl = []
#             names = [] 
#             length = []
#         ramd:  
#             repl = []
#             names = [] 
#             length = []
#             replicas_distr = [] # distribution for each replica that is generated in the bootstrapping procedure
#             replicas = []  # tauRAMD for each replica
#             replicas_SD = []
#             contact_collection - a complete list of contact residues           
#         tau_exp = None
#         tau_exp_SD = None
#         type = None
#         
# #### Functions:
#         bootstrapp(self,t) -> returens tau_bootstr
#         scan_ramd(self)    -> finds all RAMD trajectories and computes tau values
#         scan_namd(self)    -> finds all NAMD trajectories
#         analysis_all_namd(self,step_analysis=20,start_analysis = 0)
#         analysis_all_ramd(self,step_analysis=1,start_analysis = 0,repl_list=None)
#     
#     
# #########################################################################
# 
# ### 3. more functions:
#     superimpose_traj(ref,u, sel_list = [])    -> a list of RMSD for all frames
#     pbc(u,Rgr0)                               -> radius of gyration for a current frame
#     read_ligands(ligand_pdb)                  -> Rdkit objects mol and 2D image
#     ligand_analysis(ligand_pdb)               -> Two arrays : ligand names pand and ligand properties_list
#     IFP(u_mem,sel_ligands,property_list)      -> Two tables: IFP and hydrogen bonds
#     table_combine (df_HB,df_prop,ligand_name) -> table with IFP with hydrogen bonds
#     PLOT_tauRAMD_dataset(tr,tr_name = None,types_list = [""])
#        
#     



import warnings
warnings.filterwarnings("ignore")

#%load_ext autoreload
#%autoreload 2




import glob, os
import sys
import subprocess
import numpy as np

import pandas as pd
from pandas import ExcelFile 

from matplotlib import *
from matplotlib import cm
import matplotlib.ticker
import  pylab as plt
import seaborn
import seaborn as sns

#import ipywidgets as widgets

from scipy import stats

from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import EState
from rdkit.Chem import MolDb
from rdkit.Chem import QED
from rdkit.Chem import rdchem
from rdkit.Chem import ChemicalFeatures
from rdkit import RDConfig
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw

import MDAnalysis as mda
from MDAnalysis.lib.formats.libdcd import DCDFile
from MDAnalysis.analysis import contacts,align,rms
from MDAnalysis.analysis.base import AnalysisFromFunction
from MDAnalysis.coordinates.memory import MemoryReader

from sklearn import linear_model
from sklearn import preprocessing




class Trj_Properties:
    def __init__(self):
        self.start = 0
        self.stop = 0
        self.step = 1
        self.length = 0
        self.df_properties = None  # Interaction fingerprients
        self.rmsd_prot = None      # RMSD of the protein
        self.rmsd_lig = None
        self.Rgr_prot = None
        self.Rgr_lig = None
        self.com_lig = None
        


class trajectories:
    """
   
    1 Functions:
        __init__    
    2 Variables: (see description in the function __init__())
        ligand - object of the class ligand
        namd -  object of the class namd
        ramd -  object of the class ramd
        PRJ_DIR
        pdb
        top
        ramd_traj_tmpl  
        namd_traj_tmpl 
        ramd_tmpl 
        namd_tmpl 
        timestep         
        tau_exp 
        tau_exp_SD
        type

        
    3 Sub-Classes
        3.1 ligand
                Functions:
                    _int__
                Variable:
                    ligand_names
                    property_list
                    mol
                    ligand_2D
                    radius
            
        3.2 namd  
                Functions:
                    __init__
                Variable:
                    repl_traj = []
                    repl_names = [] 
                    length = []
                    step = 1
                    start = 0
                # the next set of parameters are computed by the analysis_all_namd() function
                    df_properties = []
                    rmsd_prot = []
                    rmsd_lig = []
                    Rgr_prot = []
                    Rgr_lig = []
                    contact_collection = []  # this is a container where we will accomulate all protein-ligand contacts

        3.3 ramd  
                Functions:
                    __init__
                    IFP_unify(self,subset = [])
                    IFP_save(self,subset=[],file="IFP.pkl")
                Variables:
                    repl_traj = []
                    repl_names = [] 
                    length = []
                    replicas_distr = [] # distribution for each replica that is generated in the bootstrapping procedure
                    replicas = []  # tauRAMD for each replica
                    replicas_SD = []
                    contact_collection - a complete list of contact residues  

    """
        
    #========================================================    
    def __init__(self,PRJ_DIR = "./",namd_tmpl= "NAMD*", ramd_tmpl= "RAMD*", pdb = "ref.pdb", 
                ligand_pdb = None,ligand_mol2 = None,\
                ramd_traj_tmpl = "*dcd",namd_traj_tmpl = "*dcd",timestep=1):
        """
        Class constructor:
        
        INPUT PARAMETERS:
        PRJ_DIR - directory to story data
        namd_dirs - TEMPLATE used for search of directories with NAMD simulations (should contain also complete path)
        ramd_dirs - TEMPLATE used for search of directories with RAMD simulations (should contain also complete path)
                
        """
        #---------  check/make directory to work in -----------
#                try:  
#                    os.mkdir(PRJ_DIR)
#                except OSError:  
#                    print ("Creation of the directory %s failed" % PRJ_DIR)
#                else:  
#                    print ("Data generated will be located at %s " % PRJ_DIR)
        if not os.path.isdir(PRJ_DIR):  PRJ_DIR = os.getcwd()
        if(PRJ_DIR[-1] != "/"): PRJ_DIR = PRJ_DIR+"/"
        self.PRJ_DIR = PRJ_DIR
        
        #------------ check ref structure --------------
        if not os.path.isfile(PRJ_DIR+pdb): 
            print("file %s  was not found " %(PRJ_DIR+pdb))
            return
        else: self.pdb = pdb
        
        self.ramd_traj_tmpl ="/"+ramd_traj_tmpl
        self.namd_traj_tmpl = "/"+namd_traj_tmpl
        self.ramd_tmpl ="/"+ramd_tmpl
        self.namd_tmpl = "/"+namd_tmpl
        self.timestep = timestep
        
        self.ligand = self.createLigand(PRJ_DIR,ligand_pdb,ligand_mol2) 
        self.namd = self.createNamd() 
        self.ramd = self.createRamd(PRJ_DIR,pdb,timestep) 
        self.tau_exp = None
        self.tau_exp_SD = None
        self.type = None

            
        #--------------- find NAMD and RAMD trajectories and make a list
 #       print("looking for NAMD traj. in: ",PRJ_DIR+self.namd_tmpl+self.namd_traj_tmpl)
        for file in np.sort(glob.glob(PRJ_DIR+self.namd_tmpl+self.namd_traj_tmpl)): 
            if ((file.find("vel") < 0)  and (file.find("heat") < 0)):
                self.namd.repl_traj.append(file)
                self.namd.names.append(os.path.basename(os.path.dirname(file)))
        print(len(self.namd.names)," NAMD trajectories found")
                 
        for dir_ramd in np.sort(glob.glob(PRJ_DIR+self.ramd_tmpl)): 
            ramd_list = []
#            print("looking for RAMD traj. in: ",dir_ramd+self.ramd_traj_tmpl)
            for file in np.sort(glob.glob(dir_ramd+self.ramd_traj_tmpl)): 
                if (file.find("vel") < 0):
                    ramd_list.append(file)
            if len(ramd_list)> 0: 
                self.ramd.repl_traj.append(ramd_list)
                self.ramd.names.append(os.path.basename(dir_ramd))
                print(len(ramd_list)," RAMD traj. found in ",dir_ramd)
                
                
        return  
    
   #========================================================        
    class  Ligand:
        """
                Functions:
                    _int__(self,PRJ_DIR,ligand_pdb,ligand_mol2="moe.mol2")
                Variable:
                    ligand_names
                    property_list
                    mol
                    ligand_2D
                    radius
        """
        def __init__(self,PRJ_DIR,ligand_pdb,ligand_mol2="moe.mol2"):
            self.ligands_names = []
            self.property_list = {}
            self.mol = None
            self.ligand_2D = None
            resnames = []
            DO_PDB = False 
            if ligand_pdb or ligand_mol2:                   
                if os.path.isfile(PRJ_DIR+"/"+ligand_pdb) and  os.path.isfile(PRJ_DIR+"/"+ligand_mol2):
                    try:
                        mol,list_labels,resnames=self.ligand_Mol2(PRJ_DIR+"/"+ligand_mol2)
                    except:
                        DO_PDB = True
                elif os.path.isfile(PRJ_DIR+ligand_pdb):
                        DO_PDB = True
                else:
                    print("ERROR: nether ligand PDB nor Mol2 were found in ",PRJ_DIR)
                    return
                if DO_PDB:
                    print("WARNING!!! mol2 file was not found or contains errors\n pdb file will be used instead\n Aromatic atoms can not be recognized ")
                    mol,list_labels,resnames=self.ligand_PDB(PRJ_DIR+"/"+ligand_pdb)
                try:    
                    properties_list,ligand_2D = self.ligand_properties(mol,list_labels) 
                except:
                    if DO_PDB:
                        rename_H(PRJ_DIR+"/"+ligand_pdb,PRJ_DIR+"/Corrected_Ligand.pdb")
                        mol,list_labels,resnames=self.ligand_PDB(PRJ_DIR+"/Corrected_Ligand.pdb")
                        properties_list,ligand_2D = self.ligand_properties(mol,list_labels) 
                        
                print("Ligand properties:")
                for k in properties_list:
                    print (k,properties_list[k])
                    
                self.ligands_names = np.unique(resnames)
                self.ligand_2D=ligand_2D
                self.mol = mol
                self.property_list=properties_list
            else: print(" ligand PDB and Mol2 are not defined")
                
            return
        ########################################
        #
        #     get ligand chemical properties from PDB and Mol2 files
        #
        ########################################
        def  ligand_Mol2(self,ligand_mol2):
            """
            Parameters:
            ligand_mol2 - ligand structure file  in the Mol2 format (not all mol2 format work, but generated by MOE does)
            Results:
            mol - RDKit molecular object
            list_labels - list of atom names
            resnames - list of residue names (for all atoms)
            """
            ff=open(ligand_mol2,"r")
            lines = ff.readlines()
            ff.close()
            list_labels = []
            resnames = []
            start = 0
            for line in lines:
                key = line.split()
                if line.find("<TRIPOS>ATOM") >= 0: start = 1
                elif line.find("<TRIPOS>BOND") >= 0: start = 0
                else:
                    if start == 1:  
                        list_labels.append(key[1]) 
                        resnames.append(key[7])
            
            mol = Chem.rdmolfiles.MolFromMol2File(ligand_mol2,removeHs=False)   
            return(mol,list_labels,resnames)

        ########################################
        #
        #     get ligand chemical properties from PDB file only
        #
        ########################################
        def  ligand_PDB(self,ligand_pdb):
            """
            Parameters:
            ligand_pdb - ligand structure file  in the PDB format
            Results:
            mol - RDKit molecular object
            list_labels - list of atom names
            resnames - list of residue names (for all atoms)
            """
            ff=open(ligand_pdb,"r")
            lines = ff.readlines()
            ff.close()
            list_labels = []
            resnames = []

            for line in lines:
                if line.split()[0] == 'ATOM': 
                    list_labels.append(line.split()[2]) 
                    resnames.append(line.split()[3]) 
            
            mol = Chem.MolFromPDBFile(ligand_pdb, removeHs=False)   
            return(mol,list_labels,resnames)

        ########################################
        #
        #     get ligand chemical properties from PDB file only
        #
        ########################################
        def  ligand_properties(self,mol,list_labels):
            """
            Parameters:
            mol - RDKit molecular object
            list_labels - list of atom names
            Results:
            properties_list - a dictionary containing types of chemical properties and corresponding atoms 
            """
            ligand_2D =Chem.MolFromSmiles(Chem.MolToSmiles(mol))
            fdefName = os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef')
            factory = ChemicalFeatures.BuildFeatureFactory(fdefName)
            feats = factory.GetFeaturesForMol(mol)
            properties_list = {}
            for f in feats:
                prop = f.GetFamily()  #  get property name
                at_indx  = list(f.GetAtomIds())  # get atom index
                if prop not in properties_list.keys():
                    properties_list[prop]=[]
                if(len(at_indx) > 0):
                    for l in at_indx: properties_list[prop].append(list_labels[l])
                else: properties_list[prop].append(list_labels[at_indx[0]])
            return(properties_list,ligand_2D)
        
        ########################################
        #
        #     correct PDB file (name and position of hydrogen atoms) to make it readable by RDKit
        #
        ########################################
        def rename_H(self,ligand_H_name,ligand_H_name_new = ""):
            """
            rename hydrogen atoms in a ligand file generated by openbabel ( openbabel generats all hydrogen as H)
            remove connectivity lines
            adjust position of hydrogen atom names so that H always occupies 14th position (requiered by Rdkit)
            INPUT:
            ligand pdb file
            Returns:
             name of the ligand 
             rewrite ligand structure
            """
            ff=open(ligand_H_name,"r")
            lines = ff.readlines()
            ff.close()
            lig = []
            hi = 1
            for line in lines:
                key = line.split()
                if(len(line) > 20):
                    if ((line[12:16].strip()[0] == "H") or (line[12:13] != " ")):
                        s = list(line)
                        if( line[12:16].strip() == "H"): new_name = "H"+str(hi)
                        else: new_name =  line[12:16].strip()
                        s[12:17] = str(" %-4s" %(new_name))
                        hi += 1
                        line = "".join(s)
                    if (line.split()[0] == "ATOM" or line.split()[0] == "HETATM") :   # we will skip connectivity lines
                        lig.append(line.replace("HETATM","ATOM  "))
                        resname = line[16:20].strip()

            if(ligand_H_name_new == ""): ligand_H_name_new = ligand_H_name
                    
            if  len(lig) > 0:
                ff=open(ligand_H_name_new,"w")
                for p in lig:  ff.write(p)
                ff.close()
            return
        ##########################################################################################################

        
    #========================================================    
    class  Namd:
        """
                Functions:
                    __init__(self)
                    compare_all_namd()
                    IFP_unify(self,subset = [])
                    IFP_save(self,subset=[],file="IFP.pkl")
                Variable:
                    repl = []
                    names = [] 
                    length = []
                    step = 1
                    start = 0
                    contact_collection = []
                # the next set of parameters are computed by the analysis_all_namd() function
                    traj = []
                    contact_collection = []  # this is a container where we will accomulate all protein-ligand contacts
        """
        def __init__(self):
            self.repl_traj = []
            self.names = [] 
            self.length = []
            self.step = 1
            self.start = 0
            # the next set of parameters will be filled by the analysis_all_namd() function
            self.traj = []   # an array of Trj_Properties objects for wach trajectory in a replica
            self.contact_collection = []  # this is a container where we will accomulate all protein-ligand contacts

        ##############################################################
        #
        #  function that analyze all NAMD trajectories for a particular compound 
        #
        ###############################################################
        def compare_all_namd(self):
            """
            Parameters:
            uses results of the analysis_all_namd function
            Results:
            """
            IFP_list = []
            for j,nmd in enumerate(self.names):
                for c in self.traj.df_properties[j].columns[1:].tolist():
                    if c  in IFP_list:    pass
                    elif(c != "WAT"): IFP_list.append(c)
            
            all_namd_prop  = pd.DataFrame(np.zeros((len(self.names),len(IFP_list))),index = self.names, columns = IFP_list) 

            for j,nmd in enumerate(tr.names): 
                print(nmd,self.names[j],self.replicas[j])
                a = self.traj.df_properties[j][self.traj.df_properties[j].columns[1:]].mean(axis=0)
                for key in a.index: all_namd_prop.loc[nmd][key] = a.loc[key] 
            fig = plt.figure(figsize=(6, 4))
            sns.heatmap(all_namd_prop, cmap="Greys", linewidths=.5)
            plt.show()
            return(all_namd_prop)


        ###################################################################
        #
        # FUNCTION to unify comlumns of a set of  IFP databases for generated from several trajectories  
        #
        ###################################################################
        def IFP_unify(self,subset = []):
            """
            Parameters:
            optional - a list of IFP to be used to unify tables of IFP for all compounds
            Results:
            """
            if len(subset) == 0: subset = range(0,len(self.namd.names))
            self.IFP_list = []

            for j,tr_c in enumerate(np.take(self.namd.traj,subset)):
                    for c in tr_c.df_properties.columns.tolist():
                        if c  in IFP_list:    pass
                        else: IFP_list.append(c)
            for j,tr_c in enumerate(np.take(self.namd.traj,subset)):
                    to_add = np.setdiff1d(IFP_list, np.asarray(tr_c.df_properties.columns.tolist()))
                    for k in to_add:
                        tr_c.df_properties[k] = np.zeros(tr_c.df_properties.shape[0],dtype=np.int8)
                    tr_c.df_properties = tr_c.df_properties[np.concatenate((["time"],tr_c.df_properties.columns[tr_c.df_properties.columns != "time"].tolist()))]
                    if "WAT" in tr_c.df_properties.columns.tolist():
                        tr_c.df_properties = tr_c.df_properties[np.concatenate((tr_c.df_properties.columns[tr_c.df_properties.columns != "WAT"].tolist(),["WAT"]))]
            return(IFP_list)
        
        ###################################################################
        #
        # Save IFP for a selected replicas of RAMD simulations
        #
        ###################################################################
        def IFP_save(self,subset=[],file="IFP.pkl"):
            """
            Parameters:
            optional - a list of IFP to be used to unify tables of IFP for all compounds
            Results:
            """
            self.IFP_unify(subset)
            df1 = None
            if len(subset) == 0: subset = range(0,len(self.ramd.names))
                
            IFP_list = []
            print("+++++++++++++++++",self.namd.names,subset)
            for j,tr_replica in enumerate(np.take(self.namd.traj,subset)):
                    tt = tr_c.df_properties
                    tt["Repl"] = np.repeat(self.namd.names[subset[j]],tr_c.df_properties.shape[0]) 
                    tt["Traj"] = np.repeat(str(i),tt.shape[0]) 
                    tt["RMSD"] = tr_c.rmsd_lig
                    tt["RGyr"] = tr_c.Rgr_lig
                    tt["length"] = tr_c.length
                    tt["COM"] = tr_c.com_lig
                    df1 = pd.concat([df1, tt])
            df1.to_pickle(file)
            return(df1)
        
            
   #-----------------------------------------       
    class  Ramd:
        """
            Functions:
                __init__(self)
                IFP_unify(self,subset = [])
                IFP_save(self,subset=[],file="IFP.pkl")
                bootstrapp(self,t)
                scan_ramd(self)
            Variables:
                repl_traj = []
                repl_names = [] 
                length = []
                replicas_distr = [] # distribution for each replica that is generated in the bootstrapping procedure
                replicas = []  # tauRAMD for each replica
                replicas_SD = []
                contact_collection - a complete list of contact residues  
        """
        def __init__(self,PRJ_DIR,pdb,timestep):
            #---   # array of replica parameters- each is array of trajectories
            self.repl_traj = [] #  directories with RAMD simulations for all replicas 
            self.names = [] # name of  replicas 
            self.length = []   # in ns 
            # array of replica parameters
            self.replicas_distr = [] # distribution for each replica that is generated in the bootstrapping procedure
            self.replicas = []  # tauRAMD for each replica
            self.replicas_SD = []
            self.tau = None  # computed res.time
            self.tau_SD = None
            self.PRJ_DIR = PRJ_DIR
            self.pdb = pdb
            self.timestep = timestep
            # the next set of parameters will be filled by the analysis_all_namd() function
            self.traj = []   # an array of Trj_Properties objects for wach trajectory in a replica
            self.contact_collection = []  # this is a container where we will accomulate all protein-ligand contacts

        ###################################################################
        #
        # FUNCTION to unify comlumns of a set of  IFP databases for generated from several trajectories  
        #
        ###################################################################
        def IFP_unify(self,subset = []):
            """
            Parameters:
            optional - a list of IFP to be used to unify tables of IFP for all compounds
            Results:
            """
            if len(subset) == 0: subset = range(0,len(self.ramd.names))
            self.IFP_list = []

            for j,tr_replica in enumerate(np.take(self.ramd.traj,subset)):
                for i,tr_c in enumerate(tr_replica):
                    for c in tr_c.df_properties.columns.tolist():
                        if c  in IFP_list:    pass
                        else: IFP_list.append(c)
            for j,tr_replica in enumerate(np.take(self.ramd.traj,subset)):
                for i,tr_c in enumerate(tr_replica):
                    to_add = np.setdiff1d(IFP_list, np.asarray(tr_c.df_properties.columns.tolist()))
                    for k in to_add:
                        tr_c.df_properties[k] = np.zeros(tr_c.df_properties.shape[0],dtype=np.int8)
                    tr_c.df_properties = tr_c.df_properties[np.concatenate((["time"],tr_c.df_properties.columns[tr_c.df_properties.columns != "time"].tolist()))]
                    if "WAT" in tr_c.df_properties.columns.tolist():
                        tr_c.df_properties = tr_c.df_properties[np.concatenate((tr_c.df_properties.columns[tr_c.df_properties.columns != "WAT"].tolist(),["WAT"]))]
            return(IFP_list)
        
        ###################################################################
        #
        # Save IFP for a selected replicas of RAMD simulations
        #
        ###################################################################
        def IFP_save(self,subset=[],file="IFP.pkl"):
            """
            Parameters:
            optional - a list of IFP to be used to unify tables of IFP for all compounds
            Results:
            """
            self.IFP_unify(subset)
            df1 = None
            if len(subset) == 0: subset = range(0,len(self.ramd.names))
                
            IFP_list = []
            print("+++++++++++++++++",self.ramd.names,subset)
            for j,tr_replica in enumerate(np.take(self.ramd.traj,subset)):
                for i,tr_c in enumerate(tr_replica):
                    tt = tr_c.df_properties
                    tt["Repl"] = np.repeat(self.ramd.names[subset[j]],tr_c.df_properties.shape[0]) 
                    tt["Traj"] = np.repeat(str(i),tt.shape[0]) 
                    tt["RMSD"] = tr_c.rmsd_lig
                    tt["RGyr"] = tr_c.Rgr_lig
                    tt["length"] = tr_c.length
                    tt["COM"] = tr_c.com_lig
                    df1 = pd.concat([df1, tt])
            df1.to_pickle(file)
            return(df1)
        
        ##############################################################
        #
        #    bootstrapping procedure for estimation of the residence time based on the set of RAMD dissociation times 
        #
        ###############################################################
        def bootstrapp(self,t):
            """
            Parameters:
            t - list of RAMD dissociation times
            max_shuffle - number of bootstrapping iterations
            in each iteration alpha = 80% of the list is used
            Results:
            """
            max_shuffle = 500
            alpha = 0.8
            sub_set = int(alpha*len(t))        
            tau_bootstr = []
            if sub_set > 6:
                for i in range(1,max_shuffle):
                    numpy.random.shuffle(t)
                    t_b = t[:sub_set]
                    # select time when 50% of ligand dissocate
                    t_b_sorted_50 = (np.sort(t_b)[int(len(t_b)/2.0-0.5)]+np.sort(t_b)[int(len(t_b)/2)])/2.0
                    tau_bootstr.append(t_b_sorted_50)
#                print("+++++++++++",np.mean(t_b),t_b_sorted_50,np.sort(t_b))
            return(tau_bootstr)
            
        
        ##############################################################
        #
        #   function that analyze all RAMD trajectories for a particular compound and compute its residence time  
        #
        ###############################################################
        def scan_ramd(self):
            """
            Parameters: re
            Results:
            """
            #--- read exp data-----------
            
            u = mda.Universe(self.PRJ_DIR+self.pdb)
            sd_max = 0
        
            for i,(rmd,repl) in enumerate(zip(self.names,self.repl_traj)): # loop over replicas
                ramd_l = []
                traj_properties = []
                for t in repl:  # loop over trajectories in each replica
                    u.load_new(t)  
                    if(len(u.trajectory) > 2):
                        ramd_l.append((self.timestep/1000.0)*len(u.trajectory)) # should be 2.0/1000.0 ?
                    traj_properties.append(Trj_Properties())
                self.length.append(ramd_l)
                if(len(ramd_l) > 6):
                    #-------------- bootstrapping procedure 
                    distr = self.bootstrapp(ramd_l)
                    self.replicas_distr.append(distr)
                    self.replicas.append(np.mean(distr))
                    self.replicas_SD.append(np.std(distr))
                    sd_max = max(sd_max,np.nanmax(np.std(distr)))
                else:
                    print("!!!! RAMD trajectory %s is too short, will be skipped " %rmd,"length:",len(ramd_l))
                    self.replicas.append(None)
                    self.replicas_SD.append(None)
                    self.replicas_distr.append([])
                
                # we will estimate final tau RAMD from all replicas as an average (omitting Nans, ie. incolplete simulations)
                non_empty  = np.asarray(self.replicas)[numpy.isnan(np.asarray(self.replicas).astype(float)) == False]
                if len(non_empty)>0:
                    self.tau =  np.nanmean(non_empty)
                    self.tau_SD = max(np.nanstd(non_empty),sd_max)
                self.traj.append(traj_properties)
            return
        
        ########################################
        #
        #     PLOT RAMD analysis for a particular ligand
        #
        ########################################

        def Plot_RAMD(self,lims=(0,15)):
            """
            Parameters:
            lims -  x-limits
            Returns:
            plot
            """
            color = ['r','b','forestgreen','lime','m','c','teal','orange','yellow','goldenrod','olive','tomato','salmon','seagreen']
            fig = plt.figure(figsize=(12, 2))
            time_max = 0
            for r in self.replicas_distr:
                if len(r)>0: time_max = max(time_max,np.max(r))
            x = np.linspace(start=lims[0],stop=lims[1],num=100)
            for i,(d,b) in enumerate(zip(self.replicas_distr,self.length)):
                if (self.replicas_distr[i] and len(d) > 2):
                    ax1 = sns.distplot(d, kde=True, hist = True, norm_hist = True, bins = 3, color =color[i],label=self.names[i]);
                    ax1.set_xlim(lims)    
                    ymin, ymax = ax1.get_ylim()
            if self.tau and self.tau_SD:     
                print("tauRAMD ",self.tau,self.tau_SD)
                gauss = np.exp(-np.power((x - self.tau)/self.tau_SD, 2.)/2.)
                plt.plot(x,ymax*gauss/max(gauss), 'k-', label='total', linewidth=1)

            plt.legend()
            plt.show()
            return

       
    ##############################################################
    #
    #   Functions generationg objects of the sub-classes
    #
    ###############################################################

    def createLigand(self,PRJ_DIR,ligand_pdb,ligand_mol2):
        return (trajectories.Ligand(PRJ_DIR,ligand_pdb,ligand_mol2))
                   
    def createNamd(self):
        return (trajectories.Namd())

    def createRamd(self,PRJ_DIR,pdb,timestep):
        return (trajectories.Ramd(PRJ_DIR,pdb,timestep))
        
    ##############################################################
    #
    #  function that analyze a membrane density along z axis in a trajectory 
    #
    ###############################################################
    
    def mambrane_traj(self,traj,start_analysis,step_analysis):
        """
        Parameters:
        step_analysis - step to be used to scan over the trajectory
        start_analysis - starting snapshot for analysis; if
        start_analysis < 0 - count from the end of the trajectory
        if(0 < start_analysis < 1) -  a fraction of the trajectory = start_analysis will be skipped
        traj - location and name of the trajectory to be analyzed   
        
        Results:
        u_length - total number of fraimes in the trajectory
        """
        sel_ligands = self.ligand.ligands_names[0]
        ref = mda.Universe(self.PRJ_DIR+self.pdb)
        Rgr0 = ref.select_atoms("protein").radius_of_gyration() 
        all_atoms = ref.select_atoms("not type H")
        zmin = 100

                                       

        return

    ##############################################################
    #
    #  function that analyze a trajectory 
    #  RMSD of protein and ligand, Radius of Gyration, and IFP table are computed for every nth frame
    #  input parameters - stride and the first snapshot for analysis 
    #
    ###############################################################
    
    def analysis_traj(self,traj,start_analysis,step_analysis,WB_analysis):
        """
        Parameters:
        step_analysis - step to be used to scan over the trajectory
        start_analysis - starting snapshot for analysis; if
        start_analysis < 0 - count from the end of the trajectory
        if(0 < start_analysis < 1) -  a fraction of the trajectory = start_analysis will be skipped
        WB_analysis - True if water briges has to be traced, default- False
        traj - location and name of the trajectory to be analyzed   
        
        Results:
        rmsd_prot,rmsd_lig - RMSD of the protein and ligand
        Rgr_prot, Rgr_lig - radius of Gyration of the protein and ligand
        df_prop_complete - Pandas table with a complete set of IFP
        u_length - total number of fraimes in the trajectory
        """
        sel_ligands = self.ligand.ligands_names[0]
  #      sel_l = "resname "+sel_ligands
        ref = mda.Universe(self.PRJ_DIR+self.pdb)
        Rgr0 = ref.select_atoms("protein").radius_of_gyration()  
        rmsd_prot = []
        rmsd_lig = []
        Rgr_prot = []
        Rgr_lig = []
        com_lig = []
        u = mda.Universe(self.PRJ_DIR+self.pdb)
        u.load_new(traj)  
        u_length = len(u.trajectory)
        u_size = int(os.path.getsize(traj)/(1024.*1024.))
        print("number of frames= %s; file size %s M" %(u_length,u_size))
        
        stop = len(u.trajectory)
        if(start_analysis < 0): start = stop + start_analysis
        elif(start_analysis < 1): start = len(u.trajectory)*start_analysis
        else: start = start_analysis
        if(start > stop): start = stop -1
        step = max(1,step_analysis)
                                
        system_reduced = u.select_atoms(" protein or (resname WAT "+sel_ligands+")")
        
        u_mem = mda.Merge(system_reduced).load_new(AnalysisFromFunction(lambda ag: ag.positions.copy(), system_reduced).run(start=start,stop=stop,step=step).results,format=MemoryReader)
        u_mem.dimensions = u.dimensions
#        u_mem = u
        print("will be analyzed  %s frames" %(len(u_mem.trajectory)))
        #----------------- superimposition-----
        for i in range(0,len(u_mem.trajectory)):
            u_mem.trajectory[i]
            u_mem.dimensions = u.dimensions
            Rgr = pbc(u_mem,Rgr0)
            Rgr_prot.append(u_mem.select_atoms("protein").radius_of_gyration())
            Rgr_lig.append(u_mem.select_atoms("resname "+sel_ligands).radius_of_gyration())
            rmsd = superimpose_traj(ref,u_mem,["protein","resname "+sel_ligands])  
            if(rmsd[0] > 10.0): print("for the frame %s protein RMSD is very large: %s" %(i,rmsd[0]))
            if(rmsd[1] > 10.0): print("for the frame %s ligand RMSD is very large: %s" %(i,rmsd[1]))
            com_lig.append(np.round(u_mem.select_atoms("resname "+sel_ligands).center_of_mass(),2))
            rmsd_prot.append(rmsd[0])
            rmsd_lig.append(rmsd[1])
            if(i%1000 == 0): print(i,rmsd[0],rmsd[1])
       
        df_prop,df_HB,df_WB = IFP(u_mem,sel_ligands,self.ligand.property_list,WB_analysis)
   
        return(u_length,start,rmsd_prot,rmsd_lig,Rgr_prot,Rgr_lig,com_lig,df_prop,df_HB,df_WB)



    ##############################################################
    #
    #  function that analyze all NAMD trajectories for a particular compound
    #  RMSD of protein and ligand, Radius of Gyration, and IFP table are computed for every nth frame
    #  input parameters - stride and the first snapshot for analysis 
    #
    ###############################################################
    def analysis_all_namd(self,WB_analysis = True,step_analysis=1,start_analysis = 0):
        """
        Parameters:
        step_analysis - step to be used to scan over the trajectory
        start_analysis - starting snapshot for analysis; id start_analysis < 0 - cound from the end of the trajectory
        WB_analysis - True if water briges has to be traced, default- False
        Results:
        """

#        ligands_name,property_list = ligand_analysis(dir_ligand+"/"+self.ligand.ligand_pdb)
        sel_ligands = self.ligand.ligands_names[0]
        sel_l = "resname "+self.ligand.ligands_names[0]
#        mol,ligand_2D = read_ligands(dir_ligand+"/"+ligand_pdb)
        
        ref = mda.Universe(self.PRJ_DIR+self.pdb)
        Rgr0 = ref.select_atoms("protein").radius_of_gyration()  
        for j,(nmd,repl) in enumerate(zip(self.namd.names,self.namd.repl_traj)):
            print("\n\n>>>>>>>>>>>>>>>>>","Replica: ",rep_trajl, "\n")
            step = max(self.namd.step,step_analysis)
            start = max(step_analysis, 0)
            length,start,rmsd_prot,rmsd_lig, Rgr_prot, Rgr_lig,com_lig,df_prop,df_HB,df_WB=                 self.analysis_traj(repl_traj,start,step,WB_analysis)
            df_prop_complete = table_combine(df_HB,df_WB,df_prop,sel_ligands,self.namd.contact_collection)
            self.namd.length.append((2.0/1000)*length)
            Plot_traj(rmsd_prot,rmsd_lig,Rgr_prot,Rgr_lig,nmd) 
            for contact_name in df_prop.columns.tolist():
                if contact_name not in self.namd.contact_collection:
                    self.namd.contact_collection.append(contact_name)
            self.namd.traj.append(Trj_Properties)
            self.namd.traj[j].df_properties=df_prop_complete
            self.namd.traj[j].rmsd_prot = rmsd_prot
            self.namd.traj[j].rmsd_lig = rmsd_lig
            self.namd.traj[j].Rgr_prot = Rgr_prot
            self.namd.traj[j].Rgr_lig = Rgr_lig
            self.namd.traj[j].com_lig = com_lig

        return
    
    ##############################################################
    #
    #  function that analyze all NAMD trajectories for a particular compound 
    #
    ###############################################################
    def analysis_all_ramd(self,WB_analysis = True,step_analysis=1,start_analysis = 0,repl_list= []):
        """
        Parameters:
        step_analysis - step to be used to scan over the trajectory
        start_analysis - starting snapshot for analysis; id start_analysis < 0 - cound from the end of the trajectory
        WB_analysis - run analysis of water bridges between protein and ligand; quite time-consuming
        repl_list - a list of replica numbers (indexes from a complete replica list) to be analyzed 
        Results:
        """
        
        sel_ligands = self.ligand.ligands_names[0]
        sel_l = "resname "+self.ligand.ligands_names[0]
        
        ref = mda.Universe(self.PRJ_DIR+self.pdb)
        Rgr0 = ref.select_atoms("protein").radius_of_gyration()  
        
        if len(repl_list) > 0 : repl_scan =  repl_list
        else:    repl_scan = range(0,len(self.ramd.repl_traj))
        for j1 in repl_scan:
            rmd = self.ramd.names[j1]
            repl = self.ramd.repl_traj[j1]
            print("\n\n>>>>>>>>>>>>>>>>>","Replica: ",rmd,"repl", j1,"\n")
            repl_df_properties = []
            repl_rmsd_prot = []
            repl_rmsd_lig = []
            repl_Rgr_prot = []
            repl_Rgr_lig = []
            for j2,repli in enumerate(repl):
                print(">>>>>>>>>=",j2,repli)
                step = max(step_analysis,1)
                length,start,rmsd_prot,rmsd_lig, Rgr_prot, Rgr_lig,com_lig,df_prop,df_HB,df_WB =                        self.analysis_traj(repli,start_analysis,step,WB_analysis)
                df_prop_complete = table_combine(df_HB,df_WB,df_prop,sel_ligands,self.ramd.contact_collection)
                self.namd.length.append((2.0/1000)*length)
                Plot_traj(rmsd_prot,rmsd_lig,Rgr_prot,Rgr_lig,rmd) 
                
                for contact_name in df_prop.columns.tolist():
                    if contact_name not in self.ramd.contact_collection:
                        self.namd.contact_collection.append(contact_name)
                self.ramd.traj[j1][j2].step = step
                self.ramd.traj[j1][j2].start = start
                self.ramd.traj[j1][j2].stop = length
                self.ramd.traj[j1][j2].length = length
                
                self.ramd.traj[j1][j2].df_properties = df_prop_complete
                self.ramd.traj[j1][j2].rmsd_prot = rmsd_prot
                self.ramd.traj[j1][j2].rmsd_lig = rmsd_lig
                self.ramd.traj[j1][j2].Rgr_prot = Rgr_prot
                self.ramd.traj[j1][j2].Rgr_lig = Rgr_lig
                self.ramd.traj[j1][j2].com_lig = com_lig
        return
           
        
       
    
#######################################################################
#
#     FUNCTION FOR SUPERIMPOSISION of THE TRAJECTRY FRAMES TO A REFERENCE STRUCTURE
#
#######################################################################

def superimpose_traj(ref,u, sel_list = []):
    """
    Parameters:
    u - trajectory - universe object
    ref - reference structure -universe object
    sel_list - a list of atom groups to compute RMSD
    for example - "protein" or "resname IXO"
    Results:
    """
    ur = ref
        
    ref_CA = ur.select_atoms("name CA")
    ref0 = ref_CA.positions - ref_CA.center_of_mass() 

    u_CA = u.select_atoms("name CA")
    u.atoms.translate(-u_CA.center_of_mass())
    u0 =  u_CA.positions - u_CA.center_of_mass()
    R, rmsd = align.rotation_matrix(u0,ref0)  # compute rotation matrix
    u.atoms.rotate(R)
    u.atoms.translate(ref_CA.center_of_mass()) # translate back to the old center of mass position
        
    rmsd_list = []
    for s in sel_list:
        rmsd_list.append(rms.rmsd(ur.select_atoms(s).positions,u.select_atoms(s).positions))
    
    return (rmsd_list)

#######################################################################
#
#     FUNCTION FOR PUTTING SYSTEM BACK INTO A PB BOX
#
#######################################################################

def pbc(u,Rgr0):
    """
    Parameters:
    as a check if the transformation is correct we compare radius of gyration with the reference one
    u - trajectory - universe object
    ref - reference structure -universe object
    Results:
    """
    u_CA = u.select_atoms("name CA")
    sel_p = "protein"
    
    # getting all system elements back to the box; it is important to repeat this twice in the case when protein is splitted into two parts
    u.atoms.translate(-u_CA.center_of_mass()+0.5*u.dimensions[0:3])
    u.atoms.pack_into_box(box=u.dimensions) 
    u.atoms.translate(-u_CA.center_of_mass()+0.5*u.dimensions[0:3])
    u.atoms.pack_into_box(box=u.dimensions) 
    Rgr = u.select_atoms(sel_p).radius_of_gyration()      
    if Rgr > Rgr0*1.1:
#        print("Radius of gyration is too large: %s  of that in the first frame; Try to pack system back into a box once more " %(Rgr/Rgr0)) 
        u.atoms.translate(-u_CA.center_of_mass()+0.5*u.dimensions[0:3])
        u.atoms.pack_into_box(box=u.dimensions) 
        Rgr = u.select_atoms(sel_p).radius_of_gyration()  
#        print("Radius of gyration is now: %s  of the first frame" %(Rgr/Rgr0)) 
    if Rgr > Rgr0*1.1:
        print("failed to pack the system back into a box adius of gyration is too large: %s of that in the first frame" %(Rgr/Rgr0))
    return (Rgr)


#######################################################################
#
#     FUNCTION FOR READING LIGAND structure in PDB format USING RDKit
#
#######################################################################
from SetUp.setup_membrane_simulations_AMBER import rename_H,write_by_lines
def read_ligands(ligand_pdb):
    """
    Parameters:
    ligand pdb file
    Returns:
    Rkit molecular object for the ligand and ligand image
    """
    tmp_name = ligand_pdb[:-4]+"-tmp.pdb" 
    rename_H(ligand_pdb,tmp_name)   # correct position of names of hydrogen atoms
 #   print(tmp_name)
 #   mol = Chem.MolFromPDBFile(ligand_pdb, removeHs=False)
    mol = Chem.MolFromPDBFile(tmp_name, removeHs=False)
    t1 =Chem.MolFromSmiles(Chem.MolToSmiles(mol))
    return(mol,t1)



#######################################################################
#
#      FUNCTION FOR READING LIGAND sctucture in mol2 format USING RDKit
#
#######################################################################

def read_ligands_mol2(ligand_mol2):
    """
    Parameters:
    ligand mol2 file - IMPORTANT: mol2 file created by antechamber does not work! created by MOE works
    Returns:
    Rkit molecular object for the ligand and ligand image
    """
    mol = Chem.rdmolfiles.MolFromMol2File(ligand_mol2,removeHs=False)
    try:
        sm = Chem.MolToSmiles(mol)
        t1 =Chem.MolFromSmiles(sm)
        return(mol,t1)
    except:
        print("ERROR in mol2 file",ligand_mol2)
        return(mol,None)

#######################################################################
#
#      FUNCTION FOR READING atom labels from mol2 file
#
#######################################################################

def read_ligands_mol2_AtomLabels(ligand_mol2):
    """
    Parameters:
    Returns:
    """
    radius = 0
    list_labels = []
    ff=open(ligand_mol2,"r")
    lines = ff.readlines()
    ff.close()
    start = 0
    list_resname = []
    list_pos = []
    for line in lines:
        key = line.split()
        if line.find("<TRIPOS>ATOM") >= 0: start = 1
        elif line.find("<TRIPOS>BOND") >= 0: start = 0
        else:
            if start == 1:  
                list_labels.append(key[1]) 
                list_resname.append(key[7])
                list_pos.append([float(key[2]),float(key[3]),float(key[4])])
    center = np.mean(np.asarray(list_pos),axis=1)[0]
    radius=max(np.sum(np.abs(np.asarray(list_pos)-center)**2,axis=1)**0.5)
    return (list_labels,list_resname,radius)
#######################################################################
#
#      FUNCTION FOR READING atom labels from pdb file
#
#######################################################################

def read_ligands_pdb_AtomLabels(ligand_pdb):
    """
    Parameters:
    Returns:
    """
    radius = 0
    list_labels = []
    list_resname = []
    list_pos = []
    ff=open(ligand_pdb,"r")
    lines = ff.readlines()
    ff.close()
    for line in lines:
        key = line.split()
        if key[0] == 'ATOM': 
            list_labels.append(key[2]) 
            list_resname.append(key[3])
            try:
                list_pos.append([float(key[5]),float(key[6]),float(key[7])])
            except:
                print("WARNING: Format error in %s. Ligand pdb file should not contain chain infromation" %ligand_pdb)
    center = np.mean(np.asarray(list_pos),axis=1)[0]
    radius=max(np.sum(np.abs(np.asarray(list_pos)-center)**2,axis=1)**0.5)
    return (list_labels,list_resname,radius)


########################################
#
#     get ligand chemical properties
#
########################################
def  ligand_properties(ligand_pdb,ligand_mol2):
    """
    ligand_pdb - ligand structure file  in the PDB format
    ligand_mol2 - ligand structure file  in the Mol2 format (not all mol2 format work, but generated by MOE does)
    """
    ff=open(ligand_pdb,"r")
    lines = ff.readlines()
    ff.close()
    list_labels = []
    for line in lines:
        if line.split()[0] == 'ATOM': list_labels.append(line.split()[2]) 

    mol = Chem.rdmolfiles.MolFromMol2File(ligand_mol2,removeHs=False)   
    fdefName = os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef')
    factory = ChemicalFeatures.BuildFeatureFactory(fdefName)
    feats = factory.GetFeaturesForMol(mol)

    properties_list = {}
    for f in feats:
        prop = f.GetFamily()  #  get property name
        at_indx  = list(f.GetAtomIds())  # get atom index
        if prop not in properties_list.keys():
            properties_list[prop]=[]
        if(len(at_indx) > 0):
            for l in at_indx: properties_list[prop].append(list_labels[l])
        else: properties_list[prop].append(list_labels[at_indx[0]])
    return(properties_list,mol)







